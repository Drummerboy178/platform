name: Test
on:
  workflow_dispatch:
jobs:
  run:
    runs-on: windows-latest
    steps:
      - run: |
          # INSTALL LICENSE
          mkdir -p ~/.vaadin/
          echo '{"username":"'`echo ${{secrets.TB_LICENSE}} | cut -d / -f1`'","proKey":"'`echo ${{secrets.TB_LICENSE}} | cut -d / -f2`'"}' > ~/.vaadin/proKey
        shell: bash
      - uses: browser-actions/setup-chrome@latest
        with:
          chrome-version: stable
      - uses: actions/setup-node@v4
        with:
          node-version: '18.20.5'
      - uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
      - uses: stCarolas/setup-maven@v5
        with:
          maven-version: '3.9.0'
      - run: |
          # Show commands
          set -x
          where node.exe || true
          where node || true
          # Clean stuff
          rm -rf ~/.m2/repository/
          rm -rf ~/.vaadin/node/
          # Clone repo
          git clone https://github.com/vaadin/designer-tutorial.git
          cd designer-tutorial
          # Change version
          perl -pi -e 's|(\s*<'vaadin.version'>)[^\s]+(</'vaadin.version'>)|${1}24.7.0.alpha1${2}|g' pom.xml
          # Set debug level
          echo "logging.level.com.vaadin.exampledata.NodeUtil=debug" >> src/main/resources/application.properties
          echo "logging.level.com.vaadin.flow.server.frontend=debug" >> src/main/resources/application.properties
          cat << EOF > src/main/java/com/example/application/data/TestNode.java
          package com.example.application.data;
          
          import java.io.BufferedInputStream;
          import java.io.File;
          import java.io.IOException;
          import java.io.InputStream;
          import java.nio.charset.StandardCharsets;
          import java.util.List;
          import java.util.Map;
          import java.util.concurrent.CompletableFuture;
          import java.util.concurrent.ExecutionException;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import java.util.concurrent.ForkJoinPool;
          import java.util.concurrent.TimeUnit;
          import java.util.concurrent.TimeoutException;
          
          import org.slf4j.Logger;
          import org.slf4j.LoggerFactory;
          import org.springframework.boot.CommandLineRunner;
          import org.springframework.core.Ordered;
          import org.springframework.core.annotation.Order;
          
          import com.vaadin.flow.internal.Pair;
          import com.vaadin.flow.server.frontend.FrontendUtils;
          import com.vaadin.flow.spring.annotation.SpringComponent;
          
          @SpringComponent
          @Order(Ordered.HIGHEST_PRECEDENCE)
          public class TestNode implements CommandLineRunner {
          
              private final ExecutorService executor = Executors.newFixedThreadPool(4);
          
              @Override
              public void run(String... args) throws Exception {
                  System.out.println("================================= Running NODE TESTS");
                  runCommand(List.of("where", "node.exe"));
                  runCommand(List.of("C:\\\\Users\\\\runneradmin\\\\.vaadin\\\\node\\\\node.exe", "-v"));
              }
          
              private void runCommand(List<String> command) {
                  System.out.println("Try to execute " + String.join(" ", command));
                  try {
                      Process process = createProcessBuilder(command).start();
                      CompletableFuture<Pair<String, String>> streamConsumer = consumeProcessStreams(process);
                      int exitCode = process.waitFor();
                      if (exitCode != 0) {
                          throw new IOException(
                                  "Process exited with non 0 exit code. (" + exitCode
                                          + ")");
                      }
                      String out;
                      String err;
                      try {
                          Pair<String, String> pair = streamConsumer.get(10, TimeUnit.SECONDS);
                          out = pair.getFirst();
                          err = pair.getSecond();
                      } catch (ExecutionException | TimeoutException e) {
                          System.out.println("Cannot get command output");
                          e.printStackTrace();
                          out = "";
                          err = "";
                      }
                      System.out.println(
                              "============== COMMAND OUT: >>>>[ " + out + " ]<<<<");
                      System.out.println(
                              "============== COMMAND ERR: >>>>[ " + err + " ]<<<<");
                  } catch (InterruptedException | IOException e) {
                      System.out.println(
                              "Unable to detect version of node using command "
                                      + String.join(" ", command));
                      e.printStackTrace();
                  }
                  //}
              }
          
              public static ProcessBuilder createProcessBuilder(List<String> command) {
                  ProcessBuilder processBuilder = new ProcessBuilder(command);
          
                  /*
                   * Ensure the location of the command to run is in PATH. This is in some
                   * cases needed by npm to locate a node binary.
                   */
                  File commandFile = new File(command.get(0));
                  if (commandFile.isAbsolute()) {
                      String commandPath = commandFile.getParent();
                      Map<String, String> environment = processBuilder.environment();
                      String pathEnvVar;
                      if (FrontendUtils.isWindows()) {
                          /*
                           * Determine the name of the PATH environment variable on
                           * Windows, as variables names are not case-sensitive (the
                           * common name is "Path").
                           */
                          pathEnvVar = environment.keySet().stream()
                                  .filter("PATH"::equalsIgnoreCase).findFirst()
                                  .orElse("Path");
                      } else {
                          pathEnvVar = "PATH";
                      }
          
                      String path = environment.get(pathEnvVar);
                      if (path == null || path.isEmpty()) {
                          path = commandPath;
                      } else {
                          // Ensure that a custom node is first in the path so it is used
                          // e.g. for postinstall scripts that run "node something"
                          path = commandPath + File.pathSeparatorChar + path;
                      }
                      environment.put(pathEnvVar, path);
                  }
          
                  return processBuilder;
              }
          
              public CompletableFuture<Pair<String, String>> consumeProcessStreams(
                      Process process) {
                  getLogger().debug("================= consumeProcessStreams {}",
                  ForkJoinPool.commonPool().toString());
          
                  InputStream inputStream = process.getInputStream();
                  getLogger().debug("============ IS: " + inputStream);
                  CompletableFuture<String> stdOut = CompletableFuture
                          .supplyAsync(() -> streamToString(inputStream, "IN"));
          
                  InputStream errorStream = process.getErrorStream();
                  getLogger().debug("============ ES: " + errorStream);
                  CompletableFuture<String> stdErr = CompletableFuture
                          .supplyAsync(() -> streamToString(errorStream, "ERR"));
                  return CompletableFuture.allOf(stdOut, stdErr).thenApply(
                          unused -> new Pair<>(stdOut.getNow(""), stdErr.getNow("")));
              }
          
              public static String streamToString(InputStream inputStream, String id) {
                  String ret = "";
                  getLogger().debug("============ START READING STREAM " + id);
                  try (InputStream handledStream = inputStream) {
                      if (inputStream instanceof BufferedInputStream buffered) {
                          System.out.println("================== RESETTING BUFFERED STREAM " + id);
                          buffered.reset();
                      }
                      //return IOUtils.toString(handledStream, StandardCharsets.UTF_8)
                      return new String(handledStream.readAllBytes(), StandardCharsets.UTF_8)
                              .replaceAll("\\\\R", System.lineSeparator());
                  } catch (IOException exception) {
                      // ignore exception on close()
                      getLogger().warn("Couldn't close template input stream", exception);
                  }
                  getLogger().debug("============ DONE READING STREAM " + id + " ====> " + ret);
                  return ret;
              }
          
              private static Logger getLogger() {
                  return LoggerFactory.getLogger(TestNode.class);
              }
          }
          EOF
          # Prepare frontend
          mvn vaadin:prepare-frontend -ntp -B || true
          ls -l ~/.vaadin/node/ || true
          where node.exe || true
          where node || true
          ~/.vaadin/node/node -v || true
          ~/.vaadin/node/node.exe -v || true
          ~/.vaadin/node/node --version || true
          ~/.vaadin/node/node.exe --version || true
          # Build
          mvn -ntp -B || true
        shell: bash
